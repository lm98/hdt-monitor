/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package bp.data.source

import bp.data.source.model.BloodOxygen
import bp.data.source.model.BloodOxygenMapper
import bp.data.source.model.BloodOxygenMeasurement
import bp.data.source.model.BloodPressure
import bp.data.source.model.Exercise
import bp.data.source.model.ExerciseMapper
import bp.data.source.model.ExerciseMeasurement
import bp.data.source.model.HeartRate
import bp.data.source.model.Measurement
import bp.data.source.model.Mood
import bp.data.source.model.Steps
import bp.data.source.model.StepsMapper
import bp.data.source.model.StepsMeasurement
import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.DatabaseReference
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.google.gson.Gson
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.suspendCancellableCoroutine
import org.eclipse.paho.client.mqttv3.MqttClient
import org.eclipse.paho.client.mqttv3.MqttConnectOptions
import org.eclipse.paho.client.mqttv3.MqttMessage
import kotlin.reflect.KClass

val topicBp = System.getenv().getOrDefault("MQTT_TOPIC_BP", "sensor/blood-pressure")!!
val topicHr = System.getenv().getOrDefault("MQTT_TOPIC_HR", "sensor/heart-rate")!!

val dbUrl: String? = System.getenv().getOrDefault(
    "FIREBASE_DB_URL",
    "https://wearablehbpproject-default-rtdb.europe-west1.firebasedatabase.app/"
)

val referencePath: String? = System.getenv().getOrDefault(
    "FIREBASE_REFERENCE_PATH",
    "dEgn1tJeRNC3fljY9wSOs2"
)

fun main(): Unit = runBlocking {
    val gson = Gson()

    // Initialize MQTT client
    val broker = System.getenv().getOrDefault("MQTT_BROKER", "localhost")
    val port = System.getenv().getOrDefault("MQTT_PORT", "1883")
    val mqttClient = MqttClient("tcp://$broker:$port", MqttClient.generateClientId())
    val mqttOptions = MqttConnectOptions().apply { isCleanSession = true }
    mqttClient.connect(mqttOptions)
    println("Connected to Mqtt Broker ${broker}:${port}")

    // Initialize Firebase
    val serviceAccount = {}::class.java.classLoader.getResourceAsStream("serviceAccountKey.json")
    val options = FirebaseOptions.builder()
        .setCredentials(GoogleCredentials.fromStream(serviceAccount))
        .setDatabaseUrl(dbUrl)
        .build()
    FirebaseApp.initializeApp(options)
    val db = FirebaseDatabase.getInstance()
    val refBP = db.getReference("${referencePath}/blood-pressure")
    val refExercise = db.getReference("${referencePath}/exercises")
    val refSteps = db.getReference("${referencePath}/steps")
    val refBloodOxygen = db.getReference("${referencePath}/blood-oxygen")


    launch { observeAndSendExercises(refExercise, mqttClient, gson) }
    launch { observeAndSendSteps(refSteps, mqttClient, gson) }
    launch { observeAndSendBP(refBP, mqttClient, gson) }
    launch { observeAndSendBloodOxygen(refBloodOxygen, mqttClient, gson) }
    /** MOCKUP **/
    launch { observeAndSendMood(mqttClient, gson) }
}

fun sendToMqtt(mqttClient: MqttClient, topic: String, payload: String) {
    val message = MqttMessage(payload.toByteArray()).apply {
        qos = 1
        isRetained = false
    }
    mqttClient.publish(topic, message)
    println("Published to [$topic]: $payload")
}

suspend fun <T : Any, O: Any> observeAndSendGeneric(
    ref: DatabaseReference,
    mqttClient: MqttClient,
    gson: Gson,
    topic: String,
    parsedClazz: KClass<T>,
    toSendClazz: KClass<O>,
    mapper: Mapper<T, O>,
): Unit = suspendCancellableCoroutine { continuation ->
    val listener = object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            println("Data exists: ${snapshot.exists()}")

            for (child in snapshot.children) {
                println("Raw child key: ${child.key}")
                println("Raw child value: ${child.value}")

                val measurement = child.getValue(parsedClazz.java)
                if (measurement != null) {
                    println("Parsed Measurement: $measurement")
                    val toSend = mapper.map(measurement, toSendClazz.java)
                    val payload = gson.toJson(toSend)
                    sendToMqtt(mqttClient, topic, payload)
                } else {
                    println("Failed to parse measurement for key: ${child.key}")
                }
            }
        }

        override fun onCancelled(err: DatabaseError) {
            continuation.resume(Unit) { _, _, _ -> }
        }
    }

    ref.addValueEventListener(listener)
    continuation.invokeOnCancellation {
        ref.removeEventListener(listener)
        println("Firebase listener cancelled")
    }
}

suspend fun observeAndSendBP(ref: DatabaseReference,
                           mqttClient: MqttClient,
                           gson: Gson
): Unit = suspendCancellableCoroutine { continuation ->
    val listener = object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            println("Data exists: ${snapshot.exists()}")

            for (child in snapshot.children) {
                println("Raw child key: ${child.key}")
                println("Raw child value: ${child.value}")

                val measurement = child.getValue(Measurement::class.java)
                if (measurement != null) {
                    println("Parsed Measurement: $measurement")
                    val bp = BloodPressure(measurement.systolic, measurement.diastolic, measurement.timestamp)
                    val payloadBp = gson.toJson(bp)
                    sendToMqtt(mqttClient, topicBp, payloadBp)
                    val hr = HeartRate(
                        measurement.heartRate?.hrAVG,
                        measurement.heartRate?.hrEnd,
                        measurement.heartRate?.hrMAX,
                        measurement.heartRate?.hrMC,
                        measurement.heartRate?.hrMIN,
                        measurement.heartRate?.hrStart,
                        measurement.timestamp,
                    )
                    val payloadHr = gson.toJson(hr)
                    sendToMqtt(mqttClient, topicHr, payloadHr)
                } else {
                    println("Failed to parse measurement for key: ${child.key}")
                }
            }
        }

        override fun onCancelled(err: DatabaseError) {
            continuation.resume(Unit) { _, _, _ -> }
        }

    }

    ref.addValueEventListener(listener)

    // Automatically remove listener if coroutine is cancelled
    continuation.invokeOnCancellation {
        ref.removeEventListener(listener)
        println("Firebase listener cancelled")
    }
}

suspend fun observeAndSendExercises(ref: DatabaseReference, mqttClient: MqttClient, gson: Gson) =
    observeAndSendGeneric(
        ref,
        mqttClient,
        gson,
        "sensor/exercise",
        ExerciseMeasurement::class,
        Exercise::class,
        ExerciseMapper
    )


suspend fun observeAndSendSteps(ref: DatabaseReference, mqttClient: MqttClient, gson: Gson) =
    observeAndSendGeneric(
        ref,
        mqttClient,
        gson,
        "sensor/steps",
        StepsMeasurement::class,
        Steps::class,
        StepsMapper
    )

suspend fun observeAndSendBloodOxygen(ref: DatabaseReference, mqttClient: MqttClient, gson: Gson) =
    observeAndSendGeneric(
        ref,
        mqttClient,
        gson,
        "sensor/blood-oxygen",
        BloodOxygenMeasurement::class,
        BloodOxygen::class,
        BloodOxygenMapper
    )

fun observeAndSendMood(mqttClient: MqttClient, gson: Gson) = runBlocking {
    val mood = Mood(
        mood = "Neutral",
        energyLevel = 55.0,
        timestamp = System.currentTimeMillis()
    )
    val payload = gson.toJson(mood)
    sendToMqtt(mqttClient, "sensor/mood", payload)
}