/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package bp.data.source

import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.DatabaseReference
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.google.gson.Gson
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.suspendCancellableCoroutine
import org.eclipse.paho.client.mqttv3.MqttClient
import org.eclipse.paho.client.mqttv3.MqttConnectOptions
import org.eclipse.paho.client.mqttv3.MqttMessage

fun main(): Unit = runBlocking {
    val gson = Gson()
    val latch = java.util.concurrent.CountDownLatch(1)

    // Initialize MQTT client
    val broker = System.getenv().getOrDefault("MQTT_BROKER", "localhost")
    val port = System.getenv().getOrDefault("MQTT_PORT", "1883")
    val topic = System.getenv().getOrDefault("MQTT_TOPIC", "sensor/blood-pressure")
    val mqttClient = MqttClient("tcp://$broker:$port", MqttClient.generateClientId())
    val mqttOptions = MqttConnectOptions().apply { isCleanSession = true }
    mqttClient.connect(mqttOptions)
    println("Connected to Mqtt Broker ${broker}:${port}")

    // Initialize Firebase
    val serviceAccount = {}::class.java.classLoader.getResourceAsStream("serviceAccountKey.json")
    val options = FirebaseOptions.builder()
        .setCredentials(GoogleCredentials.fromStream(serviceAccount))
        .setDatabaseUrl("https://wearablehbpproject-default-rtdb.europe-west1.firebasedatabase.app/")
        .build()
    FirebaseApp.initializeApp(options)
    val db = FirebaseDatabase.getInstance()
    val referencePath = System.getenv().getOrDefault("FIREBASE_REFERENCE_PATH", "eRgFEP18QvOubABo8bnyEr")
    val ref = db.getReference(referencePath)

    observeAndSend(ref, mqttClient, topic, gson)
}

fun sendToMqtt(mqttClient: MqttClient, topic: String, payload: String) {
    val message = MqttMessage(payload.toByteArray()).apply {
        qos = 1
        isRetained = false
    }
    mqttClient.publish(topic, message)
    println("Published to [$topic]: $payload")
}

suspend fun observeAndSend(ref: DatabaseReference,
                           mqttClient: MqttClient,
                           topic: String,
                           gson: Gson
): Unit = suspendCancellableCoroutine { continuation ->
    val listener = object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            println("Data exists: ${snapshot.exists()}")

            for (child in snapshot.children) {
                println("Raw child key: ${child.key}")
                println("Raw child value: ${child.value}")

                val measurement = child.getValue(Measurement::class.java)
                if (measurement != null) {
                    println("Parsed Measurement: $measurement")
                    val payload = gson.toJson(measurement)
                    sendToMqtt(mqttClient, topic, payload)
                } else {
                    println("Failed to parse measurement for key: ${child.key}")
                }
            }
        }

        override fun onCancelled(err: DatabaseError) {
            continuation.resume(Unit) { _, _, _ -> }
        }

    }

    ref.addValueEventListener(listener)

    // Automatically remove listener if coroutine is cancelled
    continuation.invokeOnCancellation {
        ref.removeEventListener(listener)
        println("Firebase listener cancelled")
    }
}